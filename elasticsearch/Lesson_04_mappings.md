# Маппинг

Маппинг или Тип - можно сравнить с таблицей в sql базах данных. 
Тип является скорее паттерном, описанием полей, из которых состоит таблица.

Исходные данные, то есть сам документ находится в поле `_source` - 
это поле не участвует в поиске, в нём лишь хранятся данные из документа.
Для поиска же используются поля из `маппинга`!

### Маппинг при создании индекса

Для маппинга используется ключевое слово `mappings`.

Поля документа указываются внутри поля `properties`.

Пример:

```http
PUT /users
{
  "mappings": {
    "properties": {
      "first_name": {"type": "text"},
      "height": {"type": "float"},
      "age": {"type": "integer"},
      "car": {
        "properties": {
          "brand": {"type": "keyword"},
          "model": {"type": "text"}
        }
      }
    }
  }
}
```

Поскольку поле `car` является объектом - для него необходимо тоже задать поле `properties`.

Во вложенном объекте `car` для поля `brand` был выбран тип `keyword`,
поскольку тут не нужен полнотекстовый поиск и разделение текста на множество токенов.

### Маппинг в существующий индекс

Для добавления поля в маппинг существующего индекса необходимо сразу на верхнем уровне указать поле `properites`

```http
PUT /users/_mapping
{
  "properties": {
    "created_at": {
      "type": "date"
    }
  }
}
```

### Получение маппинга

```http
GET /users/_mapping
```

```http
GET /users/_mapping/field/{field_name}
```

### Параметры полей маппинга

Помимо параметра `type`, у поля есть так же другие параметры, рассмотрим их.
```http
PUT /users/_mapping
{
  "properties": {
    "created_at": {
      "type": "date",
      "format": "dd/mm/yyyy"
    }
  }
}
```

В данном примере параметры у поля created_at: `type` и `format`

`type` - тип поля

`format` - дополнительный параметр для типа date, который указывает на формат даты

`properties` - маппинг вложенных объектов

`coerce` - булево значение, определяет отключить или включить приведение типов для поля

`doc_values` - отключает добавление поля в одну из внутренних структур данных
    в Apache Lucene, оставляет только инвертированный поиск. 
    Из чего следует, что агрегация, сортировка и сценарии работать не будут,
    но место на диске уменьшится и скорость индекса увеличится

`norms` - используется для отключения/включения релевантного поиска. 
    Отключение позволяет сэкономить место на диске.

`index` - включает/отключает индексацию поля. Сохраняет место на диске,
    искать по этому полю нельзя, агрегировать данные можно.

`null_value` - добавляет возможность использовать null значения для поля,
    при этом поле перестаёт индексироваться и участвовать в поиске.

`copy_to` - указывается поле, в которое скопируется значение из текущего поля.
Можно указать несколько полей, например, имя, фамилия, отчество.
Из трёх полей значения скопируются в одно указанное поле, и получится ФИО.

### Рекомендации по маппингу

1. Использовать тип динамического маппинга `strict`. Не использовать false, т.к. это вовсе отключает его.
2. Использовать только один из типов для строк: `text` - для полнотекстового поиска, `keyword` - для агрегации, сортировки и скриптов.
3. Не использовать приведение типов, и не полагаться на него.
4. Использовать лучше `integer` вместо `long`, и `float` вместо `double`, т.к. вторые типы занимают больше места на диске.
5. Устанавливать параметр `doc_values: false`, это отключает возможность агрегации, сортировки и скриптов у поля, но сохраняет немного места на диске.
6. Устанавливать параметр `norms: false`, если поле не используется для релевантного поиска.
7. Если поле не используется для фильтрации, то нужно отключать индексирование с помощью параметра `index: false`. Поле останется доступно для агрегации.
