# Типы в elasticsearch

В эластике есть стандартные типы, как и во всех языках: `string`, `int`, `float` etc.


Существует два сложных типа - `object` и `nested`.
Оба являются вложенными объектами, но ведут себя по-разному

>Доступ к данным вложенных объектов осуществляется через `точку`

Пример - `user.first`

### Тип object
    Вложенные документы схлопываются в массив

Исходный документ:
```json
{
  "group" : "fans",
  "user" : [ 
    {
      "first" : "John",
      "last" :  "Smith"
    },
    {
      "first" : "Alice",
      "last" :  "White"
    }
  ]
}
```

Итоговый документ:
```json
{
  "group" :        "fans",
  "user.first" : [ "alice", "john" ],
  "user.last" :  [ "smith", "white" ]
}
```

При таком поведении теряется связь между сущностями, поэтому невозможно произвести поиск по оператору `AND`

### Тип nested

    Вложенные объекты индексируются как отдельные документы

Возьмём тот же исходный документ. В итоге будет несколько документов!

Связи внутри вложенных объектов при этом сохраняются, что логично,
поскольку вложенный объект индексируется как отдельный документ.

## Тип алиас

    Создаётся алиас для поля. При обращении к алиасу все запросы будут обращаться к полю, на которое ссылается алиас

```json
PUT /users/_mapping
{
  "properties": {
    "{alias_field}": {
      "type": "alias",
      "path": "{src_field}"
    }
  }
}
```

## Приведение типов

    По умолчанию в эластике включено приведение типов

Это означает, что если в маппинге тип `float`, то мы можем передать как float, так и строку.
Оба варианта приведутся к float.

Пример:
`7.4 -> 7.4`
`"7.4" -> 7.4`

Для явного поведения следует отключать приведение типов!

## Массив

    !Данного типа в elasticsearch не существует!

Но как тогда мы используем массивы?

Проанализируем следующий массив, со значениями типа string:
```json
{
  "text": ["Test string", "with another text"],
  "analyzer": "standard"
}
```

В результате текстовые значения в массиве `склеятся по пробелу в одну строку`,
и она проанализируются как обычный текст. В этом вся хитрость!

Нетекстовые значения просто не анализируются, а хранятся как внутренние типы в Apache Lucene.

>Данные в 'массиве' должны быть одного типа.
>Можно использовать и разные типы данных, но они будут приведены к одному типу, если приведение разрешено
